<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AI C-Spine View</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; background-color: black; overflow: hidden; font-family: sans-serif; }
        
        /* 1. 컨테이너: 화면 전체를 꽉 채움 */
        .container { position: relative; width: 100vw; height: 100vh; }

        /* 2. 비디오: 맨 뒤에 배치 */
        video { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; /* 화면 꽉 차게 */
            transform: scaleX(-1); /* 거울 모드 */
            z-index: 0; 
        }

        /* 3. 투명 그림판: 비디오 바로 위에 덮음 */
        canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1);
            z-index: 1; 
            /* 디버깅용: 캔버스가 잘 덮였는지 확인하는 얇은 테두리 */
            border: 2px solid rgba(0, 255, 255, 0.3);
            box-sizing: border-box;
        }

        /* 4. 상태 메시지: 맨 앞에 띄움 */
        #status-box {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            width: 80%; text-align: center; z-index: 2;
            background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 15px;
            color: white;
        }
        #main-msg { font-size: 1.5rem; font-weight: bold; display: block; margin-bottom: 5px; }
        #debug-msg { font-size: 0.9rem; color: #aaa; }

    </style>
</head>
<body>
    <div class="container">
        <div id="status-box">
            <span id="main-msg" style="color:yellow">카메라 켜는 중...</span>
            <span id="debug-msg">잠시만 기다려주세요</span>
        </div>
        
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="module">
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const ctx = canvasElement.getContext('2d');
        const mainMsg = document.getElementById('main-msg');
        const debugMsg = document.getElementById('debug-msg');

        function onResults(results) {
            // [중요] 그림판 크기를 현재 화면 크기에 딱 맞춤 (매 프레임 확인)
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;

            // 1. 그림판을 깨끗이 지움 (투명하게)
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 2. 비디오는 그리지 않음! (뒤에 있는 video 태그가 보여줌)
            // 이렇게 해야 선이 비디오 뒤로 숨는 문제를 원천 봉쇄함.

            // 3. 얼굴 데이터가 있으면 점 찍기
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                // 좌표 변환 함수 (0~1 소수를 화면 픽셀 위치로 변환)
                const toX = (val) => val * canvasElement.width;
                const toY = (val) => val * canvasElement.height;

                // --- 데이터 계산 ---
                // 입 거리 (상순 13 - 하순 14)
                const mouthDist = Math.hypot(landmarks[13].x - landmarks[14].x, landmarks[13].y - landmarks[14].y);
                // 얼굴 길이 (이마 10 - 턱 152)
                const faceHeight = Math.hypot(landmarks[10].x - landmarks[152].x, landmarks[10].y - landmarks[152].y);
                // 비율 계산
                const ratio = (mouthDist / faceHeight) * 100;
                
                // 회전 계산 (코 1 - 양쪽 귀 234, 454)
                const leftEarDist = Math.hypot(landmarks[1].x - landmarks[234].x, landmarks[1].y - landmarks[234].y);
                const rightEarDist = Math.hypot(landmarks[1].x - landmarks[454].x, landmarks[1].y - landmarks[454].y);
                const yaw = leftEarDist / rightEarDist;

                // --- UI 로직 ---
                const isMouthOpen = ratio > 7.0;
                const isCentered = yaw > 0.6 && yaw < 1.4;
                const isReady = isMouthOpen && isCentered;

                debugMsg.innerText = `입크기: ${ratio.toFixed(1)}% | 회전: ${yaw.toFixed(2)}`;

                let color = '#FF0055'; // 기본 빨강

                if (isReady) {
                    mainMsg.innerText = "촬영 가능 (READY)";
                    mainMsg.style.color = "#00FF00";
                    color = "#00FF00"; // 성공 시 초록
                } else {
                    mainMsg.style.color = "#FF0055";
                    if(!isMouthOpen) mainMsg.innerText = "입을 크게 벌리세요";
                    else mainMsg.innerText = "정면을 보세요";
                }

                // --- [확실한 그리기] 선 두껍게, 점 크게 ---
                ctx.lineWidth = 3;
                ctx.strokeStyle = color;
                ctx.fillStyle = color;

                // 4. 얼굴 십자선 그리기 (무조건 보여야 함)
                ctx.beginPath();
                // 세로선 (이마 -> 턱)
                ctx.moveTo(toX(landmarks[10].x), toY(landmarks[10].y));
                ctx.lineTo(toX(landmarks[152].x), toY(landmarks[152].y));
                // 가로선 (왼눈 -> 오른눈)
                ctx.moveTo(toX(landmarks[33].x), toY(landmarks[33].y));
                ctx.lineTo(toX(landmarks[263].x), toY(landmarks[263].y));
                ctx.stroke();

                // 5. 코 끝에 왕점 찍기
                ctx.beginPath();
                ctx.arc(toX(landmarks[1].x), toY(landmarks[1].y), 8, 0, 2 * Math.PI);
                ctx.fill();

                // 6. 입술 윤곽 점 찍기 (확인용)
                [13, 14, 61, 291].forEach(idx => {
                    ctx.beginPath();
                    ctx.arc(toX(landmarks[idx].x), toY(landmarks[idx].y), 4, 0, 2 * Math.PI);
                    ctx.fill();
                });

            } else {
                mainMsg.innerText = "얼굴 인식 중...";
                mainMsg.style.color = "yellow";
                debugMsg.innerText = "카메라를 봐주세요";
            }
        }

        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await faceMesh.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();
    </script>
</body>
</html>
